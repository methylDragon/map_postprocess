#!/usr/bin/env python

import rospy
import cv2
import numpy as np

from nav_msgs.msg import OccupancyGrid


# PIXEL VALUES =================================================================
FREE_ROS = 0
UNKNOWN_ROS = 255 # -1
OBSTACLE_ROS = 100 # 100% occupancy

FREE_IMG = 254
UNKNOWN_IMG = 205
OBSTACLE_IMG = 0 # 0% brightness (black)

ITERATIONS = 6


# UTILITY FUNCTIONS ============================================================
def get_map_values(img):
    """Get unique pixel values in map."""
    out = set()
    for row in img:
        for px in row:
            out.add(px)
    return out

def get_ranges(img):
    """Generate value ranges using the values' midpoints."""
    values = list(get_map_values(img))
    values.sort()

    dividers = [int(values[i] + (values[i+1] - values[i]) / 2)
                for i in range(len(values) - 1)
                if i < len(values)]

    range_points = [values[0]]
    range_points.extend(dividers)
    range_points.append(values[-1])

    return list(zip(range_points, range_points[1:]))

def show_img(img, flags=cv2.WINDOW_AUTOSIZE):
    cv2.namedWindow("img", flags)
    cv2.imshow("img", img)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

def make_img(shape, color, dtype=np.uint8):
    new_img = np.zeros(shape, dtype)
    new_img[:]=color
    return new_img

class MapPostproc:
    def __init__(self):
        rospy.init_node('map_postprocess')
        rospy.Subscriber("/merged/map", OccupancyGrid, self.cb)

        self.msg = None

        # header
        # info
        # data

    def cb(self, data):
        self.msg = data

        rospy.loginfo(data.header)
        rospy.loginfo(data.info)

if __name__ == '__main__':
    node = MapPostproc()

    # rospy.spin()

info = node.msg.info
img_in = np.array(node.msg.data, dtype=np.uint8).reshape(info.height, info.width)

img = img_in.copy()
img[(img_in == FREE_ROS)] = FREE_IMG
img[(img_in == UNKNOWN_ROS)] = UNKNOWN_IMG
img[(img_in == OBSTACLE_ROS)] = OBSTACLE_IMG

free_mask = cv2.inRange(img, FREE_IMG, FREE_IMG)
unknown_mask = cv2.inRange(img, UNKNOWN_IMG, UNKNOWN_IMG)
obstacle_mask = cv2.inRange(img, OBSTACLE_IMG, OBSTACLE_IMG)

show_img(img)
show_img(free_mask)
show_img(unknown_mask)
show_img(obstacle_mask)

erosion_size = 1
kernel = cv2.getStructuringElement(
    cv2.MORPH_ELLIPSE,
    (2 * erosion_size + 1, 2 * erosion_size + 1)
)

free_mask_ = cv2.erode(free_mask, kernel, iterations=ITERATIONS)
free_mask_ = cv2.dilate(free_mask_, kernel, iterations=ITERATIONS)

new_img = make_img(img.shape, (-1), dtype=np.uint8)
new_img[(free_mask_ != 0)] = FREE_ROS
new_img[(obstacle_mask != 0)] = OBSTACLE_ROS

new_img_ = new_img.copy()
new_img_[(new_img_ == FREE_ROS)] = FREE_IMG
new_img_[(new_img_ == UNKNOWN_ROS)] = UNKNOWN_IMG
new_img_[(new_img_ == OBSTACLE_ROS)] = OBSTACLE_IMG

show_img(new_img_, flags=cv2.WINDOW_NORMAL)
show_img(img, flags=cv2.WINDOW_NORMAL)
# img[img == 254].shape
# show_img(img)
# get_map_values(img_in)
# get_map_values(img)
